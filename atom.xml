<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jae&#39;s Blog</title>
  
  <subtitle>Learn more, Know less.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-14T08:28:33.252Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jae</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android Proguard记录及通用配置</title>
    <link href="http://yoursite.com/2019/08/14/Android-Proguard%E8%AE%B0%E5%BD%95%E5%8F%8A%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/08/14/Android-Proguard记录及通用配置/</id>
    <published>2019-08-14T06:44:58.000Z</published>
    <updated>2019-08-14T08:28:33.252Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Android混淆知识记录"><a href="#Android混淆知识记录" class="headerlink" title="Android混淆知识记录"></a>Android混淆知识记录</h4><p>目前网上这方面的文章一大堆，在此记录有效重点部分。</p><h4 id="1、混淆在gradle中的配置代码"><a href="#1、混淆在gradle中的配置代码" class="headerlink" title="1、混淆在gradle中的配置代码"></a>1、混淆在gradle中的配置代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled true // 混淆</span><br><span class="line">            zipAlignEnabled true // Zipalign优化</span><br><span class="line">            shrinkResources true  // 移除无用的resource文件</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;  // 加载默认混淆配置文件</span><br><span class="line">            signingConfig signingConfigs.relealse  // 签名</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2、目前公认的无需混淆的地方"><a href="#2、目前公认的无需混淆的地方" class="headerlink" title="2、目前公认的无需混淆的地方"></a>2、目前公认的无需混淆的地方</h4><ul><li>枚举</li><li>自定义控件</li><li>四大组件</li><li>实体类</li><li>被反射的元素</li><li>JNI调用的Java方法</li><li>native方法</li><li>第三方库</li></ul><h4 id="3、retrace的使用"><a href="#3、retrace的使用" class="headerlink" title="3、retrace的使用"></a>3、retrace的使用</h4><p>混淆后会在./build/outputs/mapping/release/下生成映射文件及其他说明文件。</p><ul><li>dump.txt<br>说明 APK 内所有类文件的内部结构。</li><li>mapping.txt<br>提供混淆前后的内容对照表，内容主要包含类、方法和类的成员变量。</li><li>seeds.txt<br>罗列出未进行混淆处理的类和成员。</li><li>usage.txt<br>罗列出从 APK 中移除的代码。</li></ul><p>在Android SDK目录下的/tools/proguard/bin中，双击proguardgui.bat可执行文件，然后导入mapping文件与粘上报错代码。就可查看对应的错误源代码。</p><p><strong>注意事项：</strong></p><ul><li>mapping每次build都不一样，需要留存副本；</li><li>提示unknown报错在proguard-rules.pro中放开下行代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 保留源文件名和具体代码行号</span><br><span class="line">-keepattributes SourceFile,LineNumberTable</span><br></pre></td></tr></table></figure><h4 id="4、自定义Proguard模板"><a href="#4、自定义Proguard模板" class="headerlink" title="4、自定义Proguard模板"></a>4、自定义Proguard模板</h4><p>原理：因为Java语言是支持双字符的，所以可以将包名，类名，变量名，方法名定义成中文，或者其他国家的语言都可以的。</p><ul><li>自己在项目根目录下new一个TXT文件，名字随便取，里面加入很多行字符<br>在<code>Proguard-rules.pro</code> 中加入：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-obfuscationdictionary ../your-proguard-new-dic.txt</span><br><span class="line">-packageobfuscationdictionary ../your-proguard-new-dic.txt</span><br><span class="line">-classobfuscationdictionary ../your-proguard-new-dic.txt</span><br></pre></td></tr></table></figure><ul><li>使用GitHub上的Proguard开源项目</li></ul><p>下载下来后修改SimpleNameFactory.java与SourceFileRenamee.java文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleNameFactory implements NameFactory &#123;</span><br><span class="line">    /**</span><br><span class="line">    * u4e00 - u9fa5 (中文)</span><br><span class="line">    * x3130 - x318F (韩文)</span><br><span class="line">    * u800 - u4e00 (日文)</span><br><span class="line">    * 0F00 - 0FFF (藏文)</span><br><span class="line">    */</span><br><span class="line">    private static final int CHARACTER_COUNT = /*26*/ 0x9fa5-0x4e00;</span><br><span class="line">    private static final int CHARACTER_START = 0x4f99;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 随机生成一个五字符串内容</span><br><span class="line">    */</span><br><span class="line">    private String stringAt(int index)&#123;</span><br><span class="line">        return new String(new char[]&#123;</span><br><span class="line">            (char)(CHARACTER_START + index),</span><br><span class="line">            (char)(CHARACTER_START + 1 + index),</span><br><span class="line">            (char)(CHARACTER_START + 2 +index),</span><br><span class="line">            (char)(CHARACTER_START + 3 +index),</span><br><span class="line">            (char)(CHARACTER_START + 4 +index),</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 生成新的名字</span><br><span class="line">    */</span><br><span class="line">    private String newName(int index)&#123;</span><br><span class="line">        int baseIndex = index / CHARACTER_COUNT;</span><br><span class="line">        int offset = index % CHARACTER_COUNT;</span><br><span class="line"></span><br><span class="line">        String newStr = stringAt(offset);//取到中文字符串</span><br><span class="line">        String newName = baseIndex == 0 ? new String(newStr) : (name(baseIndex - 1) + newStr)</span><br><span class="line">        return newName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>混淆后的效果跟上面的一样。</p><h4 id="通用基础混淆配置"><a href="#通用基础混淆配置" class="headerlink" title="通用基础混淆配置"></a>通用基础混淆配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"># 设置混淆的压缩比率 0 ~ 7</span><br><span class="line">-optimizationpasses 5  </span><br><span class="line"># 混淆时不使用大小写混合，混淆后的类名为小写</span><br><span class="line">-dontusemixedcaseclassnames  </span><br><span class="line"># 指定不去忽略非公共库的类</span><br><span class="line">-dontskipnonpubliclibraryclasses</span><br><span class="line"># 指定不去忽略非公共库的成员</span><br><span class="line">-dontskipnonpubliclibraryclassmembers</span><br><span class="line"># 混淆时不做预校验</span><br><span class="line">-dontpreverify</span><br><span class="line"># 混淆时不记录日志</span><br><span class="line">-verbose</span><br><span class="line"># 忽略警告</span><br><span class="line">-ignorewarning</span><br><span class="line"># 代码优化</span><br><span class="line">-dontshrink  </span><br><span class="line"># 不优化输入的类文件，个人需求添加，开启无法去掉日志</span><br><span class="line"># -dontoptimize</span><br><span class="line"># 保留注解不混淆，这行按个人需求添加</span><br><span class="line"># -keepattributes *Annotation*,InnerClasses</span><br><span class="line"># 避免混淆泛型</span><br><span class="line">-keepattributes Signature  </span><br><span class="line"># 保留代码行号，方便异常信息的追踪</span><br><span class="line">-keepattributes SourceFile,LineNumberTable  </span><br><span class="line"># 混淆采用的算法</span><br><span class="line">-optimizations !code/simplification/cast,!field/*,!class/merging/*  </span><br><span class="line"></span><br><span class="line"># dump.txt文件列出apk包内所有class的内部结构</span><br><span class="line">-dump class_files.txt</span><br><span class="line"># seeds.txt文件列出未混淆的类和成员</span><br><span class="line">-printseeds seeds.txt</span><br><span class="line"># usage.txt文件列出从apk中删除的代码</span><br><span class="line">-printusage unused.txt</span><br><span class="line"># mapping.txt文件列出混淆前后的映射</span><br><span class="line">-printmapping mapping.txt</span><br><span class="line"></span><br><span class="line"># 不需要混淆的类</span><br><span class="line">-keep public class * extends android.app.Fragment</span><br><span class="line">-keep public class * extends android.app.Activity</span><br><span class="line">-keep public class * extends android.app.Application</span><br><span class="line">-keep public class * extends android.app.Service</span><br><span class="line">-keep public class * extends android.content.BroadcastReceiver</span><br><span class="line">-keep public class * extends android.preference.Preference</span><br><span class="line">-keep public class * extends android.content.ContentProvider</span><br><span class="line">-keep public class * extends android.support.v4.**</span><br><span class="line">-keep public class * extends android.support.annotation.**</span><br><span class="line">-keep public class * extends android.support.v7.**</span><br><span class="line">-keep public class * extends android.app.backup.BackupAgentHelper</span><br><span class="line">-keep public class * extends android.preference.Preference</span><br><span class="line">-keep public class * extends android.view.View</span><br><span class="line">-keep public class com.android.vending.licensing.ILicensingService</span><br><span class="line"></span><br><span class="line"># 如果是androidx包，更换包名，可省略v4、v7、design等support的配置语句</span><br><span class="line">-keep class android.support.** &#123;*;&#125;</span><br><span class="line"># v4</span><br><span class="line">-dontwarn android.support.v4.**</span><br><span class="line">-keep class android.support.v4.app.** &#123; *; &#125;</span><br><span class="line">-keep interface android.support.v4.app.** &#123; *; &#125;</span><br><span class="line">-keep class android.support.v4.** &#123; *; &#125;</span><br><span class="line"># v7</span><br><span class="line">-dontwarn android.support.v7.**</span><br><span class="line">-keep class android.support.v7.internal.** &#123; *; &#125;</span><br><span class="line">-keep interface android.support.v7.internal.** &#123; *; &#125;</span><br><span class="line">-keep class android.support.v7.** &#123; *; &#125;</span><br><span class="line"># design</span><br><span class="line">-dontwarn android.support.design.**</span><br><span class="line">-keep class android.support.design.** &#123; *; &#125;</span><br><span class="line">-keep interface android.support.design.** &#123; *; &#125;</span><br><span class="line">-keep public class android.support.design.R$* &#123; *; &#125;</span><br><span class="line"></span><br><span class="line"># 自定义控件</span><br><span class="line">-keep public class * extends android.view.View&#123;</span><br><span class="line">    *** get*();</span><br><span class="line">    void set*(***);</span><br><span class="line">    public &lt;init&gt;(android.content.Context);</span><br><span class="line">    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);</span><br><span class="line">    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#关闭日志</span><br><span class="line">-assumenosideeffects class android.util.Log &#123;</span><br><span class="line">    public static *** d(...);</span><br><span class="line">    public static *** v(...);</span><br><span class="line">    public static *** i(...);</span><br><span class="line">    public static *** e(...);</span><br><span class="line">    public static *** w(...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#避免资源混淆</span><br><span class="line">-keep class **.R$* &#123;*;&#125;</span><br><span class="line"></span><br><span class="line">#避免layout中onclick方法（android:onclick=&quot;onClick&quot;）混淆</span><br><span class="line">-keepclassmembers class * extends android.app.Activity&#123;</span><br><span class="line">    public void *(android.view.View);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#避免回调函数 onXXEvent 混淆</span><br><span class="line">-keepclassmembers class * &#123;</span><br><span class="line">    void *(*Event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#避免混淆native方法</span><br><span class="line">-keepclasseswithmembernames class * &#123;</span><br><span class="line">    native &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#避免Parcelable混淆，也可在实体类中加入@Keep注释</span><br><span class="line">-keep class * implements android.os.Parcelable &#123;</span><br><span class="line">  public static final android.os.Parcelable$Creator *;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#避免Serializable接口的子类中指定的某些成员变量和方法混淆</span><br><span class="line">-keepclassmembers class * implements java.io.Serializable &#123;</span><br><span class="line">    static final long serialVersionUID;</span><br><span class="line">    private static final java.io.ObjectStreamField[] serialPersistentFields;</span><br><span class="line">    !static !transient &lt;fields&gt;;</span><br><span class="line">    private void writeObject(java.io.ObjectOutputStream);</span><br><span class="line">    private void readObject(java.io.ObjectInputStream);</span><br><span class="line">    java.lang.Object writeReplace();</span><br><span class="line">    java.lang.Object readResolve();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#WebView混淆配置</span><br><span class="line">-keepclassmembers class fqcn.of.javascript.interface.for.webview &#123;</span><br><span class="line">    public *;</span><br><span class="line">&#125;</span><br><span class="line">-keepclassmembers class * extends android.webkit.webViewClient &#123;</span><br><span class="line">    public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap);</span><br><span class="line">    public boolean *(android.webkit.WebView, java.lang.String);</span><br><span class="line">&#125;</span><br><span class="line">-keepclassmembers class * extends android.webkit.webViewClient &#123;</span><br><span class="line">    public void *(android.webkit.webView, jav.lang.String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#第三方库混淆规则都有proguard文件，直接copy加入，没有就自己写</span><br><span class="line">-keep***&#123;*&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1、<a href http: www.520monkey.com archives 992"">Android安全防护之旅—带你把Apk混淆成中文语言代码</a><br>2、<a href https: juejin.im entry 58f6d2a10ce463006bc9e6af"">ProGuard 最全混淆规则说明</a><br>3、<a href https: juejin.im post 5d1717996fb9a07eeb13bc95#heading-3"">一篇文章带你领略Android混淆的魅力</a><br>4、<a href https: www.jianshu.com p 90feb5c50cce"">Android常用混淆配置</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Android混淆知识记录&quot;&gt;&lt;a href=&quot;#Android混淆知识记录&quot; class=&quot;headerlink&quot; title=&quot;Android混淆知识记录&quot;&gt;&lt;/a&gt;Android混淆知识记录&lt;/h4&gt;&lt;p&gt;目前网上这方面的文章一大堆，在此记录有效重点部分。&lt;
      
    
    </summary>
    
    
      <category term="Android基础知识笔记" scheme="http://yoursite.com/tags/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android UI —— Activity、Window、View</title>
    <link href="http://yoursite.com/2019/08/09/Android%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/08/09/Android绘制流程/</id>
    <published>2019-08-09T03:02:13.000Z</published>
    <updated>2019-08-14T08:44:02.423Z</updated>
    
    <content type="html"><![CDATA[<p>网上有很多关于此内容的文章，在此记录我认为重点的部分。</p><p>首先是概念性的东西：<br>1、window、phoneWindow、decorView</p><ul><li>window，抽象类，本质是surface。phoneWindow，window的实际实现类。decorView，实际显示中view层最顶层节点，由phoneWindow实例化。window按层级优先级排序分为三种，数字越大，优先级越高，越在最上面。</li></ul><table><thead><tr><th align="center">window</th><th align="center">层级</th></tr></thead><tbody><tr><td align="center">应用window</td><td align="center">1 ~ 99</td></tr><tr><td align="center">子window</td><td align="center">1000 ~ 1999</td></tr><tr><td align="center">系统window</td><td align="center">2000 ~ 2999</td></tr></tbody></table><ul><li>WindowManger、WindowMangerImpl、WindowMangerGlobal、WindowMangerService<br>WindowManger是扩展了ViewManger的接口；WindowMangerImpl是其简单的实现类、所有工作交给了WindowMangerGlobal实体去处理，管理着所有window下面所有的view、viewgroup、ViewRootImpl 。WindowMangerService是Android系统架构中的管理所有窗口的服务类，它会为每个应用分配一个session，WindowMangerGlobal会通过IWindowSession这一Binder对象调用session，session再调用WMS来处理window</li></ul><p>2、Activity、ActivityMangerService、ActivityThread调用关系</p><p><img src="http://img2.tbcdn.cn/L1/461/1/f4b04f3990e42231288c3590f2ff31b629f2f9f5" alt="图1"></p><p>3、View、ViewRoot、ViewRootImpl<br>View的事件处理都在ViewRoot类中，然后通过Window回调给Activity。</p><p>4、Activity、Window、View调用关系</p><p><img src="https://images2015.cnblogs.com/blog/1113789/201703/1113789-20170317154601651-206880525.png" alt="图2"></p><h3 id="相关引用资料"><a href="#相关引用资料" class="headerlink" title="相关引用资料"></a>相关引用资料</h3><p>1、<a href https: blog.csdn.net freekiteyu article details 79408969"">一篇文章看明白 Activity 与 Window 与 View 之间的关系</a><br>2、<a href https: blog.csdn.net yhaolpz article details 68936932"">Android 带你彻底理解 Window 和 WindowManager</a><br>3、<a href https: yq.aliyun.com articles 3005?utm_campaign="wenzhang&utm_medium=article&utm_source=QQ-qun&utm_content=m_8719" "">Android绘制流程</a><br>4、<a href https: www.cnblogs.com tiger-wang-ms p 6517048.html"">源码分析篇 - Android绘制流程（一）窗口启动流程分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网上有很多关于此内容的文章，在此记录我认为重点的部分。&lt;/p&gt;
&lt;p&gt;首先是概念性的东西：&lt;br&gt;1、window、phoneWindow、decorView&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;window，抽象类，本质是surface。phoneWindow，window的实际实
      
    
    </summary>
    
    
      <category term="Android原理知识汇总" scheme="http://yoursite.com/tags/Android%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
  <entry>
    <title>浏览器渲染的原理</title>
    <link href="http://yoursite.com/2019/08/07/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/08/07/浏览器渲染的原理/</id>
    <published>2019-08-07T06:35:37.000Z</published>
    <updated>2019-08-11T09:28:52.778Z</updated>
    
    <content type="html"><![CDATA[<p><a href https: coolshell.cn articles 9666.html"">(本文摘抄自耗子叔的博客，更多详情请查看原文)</a><br><a href https: developers.google.com web fundamentals performance rendering "">Google Developer的说明</a>，也可以直接查看cn的。</p><p><strong><em>以下是google上查找的浏览器重排的绘制视频：</em></strong><br><a href https: www.youtube.com watch?v="nJtBUHyNBxs&hl=zh-cn" ">YouTuBe上的浏览器reflow的视频：google.co.jp 重排</a><br><a href https: www.youtube.com watch?v="ZTnIxIA5KGw&hl=zh-cn" "">YouTuBe上的浏览器reflow的视频：mozilla.org 重排</a><br><a href https: www.youtube.com watch?v="dndeRnzkJDU&hl=zh-cn" "">YouTuBe上的浏览器reflow的视频：ja.wikipedia.org 重排</a></p><p><img src="/.com//image01.png" alt="图1"></p><p>1）浏览器会解析三个东西：</p><p>一个是HTML/SVG/XHTML，事实上，Webkit有三个C++的类对应这三类文档。解析这三种文件会产生一个DOM Tree。<br>CSS，解析CSS会产生CSS规则树。<br>JavaScript，脚本，主要是通过DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree.</p><p>2）解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。注意：<br>Rendering Tree 渲染树并不等同于DOM树，因为一些像Header或display:none的东西就没必要放在渲染树中了。<br>CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element。也就是DOM结点。也就是所谓的Frame。<br>然后，计算每个Frame（也就是每个Element）的位置，这又叫layout和reflow过程。</p><p>3）最后通过调用操作系统Native GUI的API绘制。<br>注意：CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，你就会在N多地方看到很多人都告诉你，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去</p><p>这里要说两个重要概念，一个是Reflow，另一个是Repaint。这两个不是一回事。</p><ul><li>Repaint——屏幕的一部分要重画，比如某个CSS的背景色变了。但是元素的几何尺寸没有变。</li><li>Reflow——意味着元件的几何尺寸变了，我们需要重新验证并计算Render Tree。是Render Tree的一部分或全部发生了变化。这就是Reflow，或是Layout。（HTML使用的是flow based layout，也就是流式布局，所以，如果某元件的几何尺寸发生了变化，需要重新布局，也就叫reflow）reflow 会从<code>&lt;html&gt;</code>这个root frame开始递归往下，依次计算所有的结点几何尺寸和位置，在reflow过程中，可能会增加一些frame，比如一个文本字符串必需被包装起来。</li></ul><p>在一些高性能的电脑上也许还没什么，但是如果reflow发生在手机上，那么这个过程是非常痛苦和耗电的。<br>所以，下面这些动作有很大可能会是成本比较高的。</p><ul><li>当你增加、删除、修改DOM结点时，会导致Reflow或Repaint</li><li>当你移动DOM的位置，或是搞个动画的时候。</li><li>当你修改CSS样式的时候。</li><li>当你Resize窗口的时候（移动端没有这个问题），或是滚动的时候。</li><li>当你修改网页的默认字体时。</li></ul><p>注：display:none会触发reflow，而visibility:hidden只会触发repaint，因为没有发现位置变化。</p><p>基本上来说，reflow有如下的几个原因：</p><ul><li>Initial。网页初始化的时候。</li><li>Incremental。一些Javascript在操作DOM Tree时。</li><li>Resize。其些元件的尺寸变了。</li><li>StyleChange。如果CSS的属性发生变化了。</li><li>Dirty。几个Incremental的reflow发生在同一个frame的子树上。</li></ul><p><strong>减少reflow/repaint</strong><br>下面是一些Best Practices：</p><p>1）不要一条一条地修改DOM的样式。与其这样，还不如预先定义好css的class，然后修改DOM的className。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">var left = 10,</span><br><span class="line">top = 10;</span><br><span class="line">el.style.left = left + <span class="string">"px"</span>;</span><br><span class="line">el.style.top  = top  + <span class="string">"px"</span>;</span><br><span class="line"></span><br><span class="line">// Good</span><br><span class="line">el.className += <span class="string">" theclassname"</span>;</span><br><span class="line"></span><br><span class="line">// Good</span><br><span class="line">el.style.cssText += <span class="string">"; left: "</span> + left + <span class="string">"px; top: "</span> + top + <span class="string">"px;"</span>;</span><br></pre></td></tr></table></figure><p>2）把DOM离线后修改。（除非有必要）<br>如：使用documentFragment 对象在内存里操作DOM<br>先把DOM给display:none(有一次reflow)，然后你想怎么改就怎么改。比如修改100次，然后再把他显示出来。<br>clone一个DOM结点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下。<br>3）不要把DOM结点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性。</p><p>4）尽可能的修改层级比较低的DOM。当然，改变层级比较底的DOM有可能会造成大面积的reflow，但是也可能影响范围很小。</p><p>5）为动画的HTML元件使用fixed或absoult的position，那么修改他们的CSS是不会reflow的。</p><p>6）千万不要使用table布局。因为可能很小的一个小改动会造成整个table的重新布局。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href https: coolshell.cn articles 9666.html&quot;&quot;&gt;(本文摘抄自耗子叔的博客，更多详情请查看原文)&lt;/a&gt;&lt;br&gt;&lt;a href https: developers.google.com web fundamentals per
      
    
    </summary>
    
    
      <category term="web前端知识储备" scheme="http://yoursite.com/tags/web%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/"/>
    
  </entry>
  
  <entry>
    <title>web双向绑定的原理</title>
    <link href="http://yoursite.com/2019/08/07/web%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/08/07/web双向绑定的原理/</id>
    <published>2019-08-07T06:16:15.000Z</published>
    <updated>2019-08-11T04:07:56.093Z</updated>
    
    <content type="html"><![CDATA[<p>JS方法Object.defineProperty()，此方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。<br>1、语法<br><code>Object.defineProperty(obj, prop, descriptor)</code><br>2、参数<br>Obj：要在其上定义属性的对象。<br>Prop：要定义或修改的属性的名称。<br>Descriptor：将被定义或修改的属性描述符</p><p>数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。存取描述符是由getter-setter函数对描述的属性。描述符必须是这两种形式之一；不能同时是两者。<br>数据描述符和存取描述符均具有以下可选键值：</p><ul><li>configurable<br>当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</li><li>enumerable<br>当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。</li></ul><p>数据描述符同时具有以下可选键值：</p><ul><li><p>value<br>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认undefined。</p></li><li><p>writable<br>当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。<br>存取描述符同时具有以下可选键值：</p></li><li><p>get<br>一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。<br>默认为 undefined。</p></li><li><p>set<br>一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。<br>默认为 undefined。</p></li><li><p>描述符可同时具有的键值</p></li></ul><table><thead><tr><th align="center">configurable</th><th align="center">enumerable</th><th align="center">value</th><th align="center">writable</th><th align="center">get</th><th align="center">set</th></tr></thead><tbody><tr><td align="center">数据描述符</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">No</td></tr><tr><td align="center">存取描述符</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">No</td><td align="center">No</td><td align="center">Yes</td></tr></tbody></table><p>如果一个描述符不具有value,writable,get 和 set 任意一个关键字，那么它将被认为是一个数据描述符。如果一个描述符同时有(value或writable)和(get或set)关键字，将会产生一个异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JS方法Object.defineProperty()，此方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。&lt;br&gt;1、语法&lt;br&gt;&lt;code&gt;Object.defineProperty(obj, prop, descriptor)&lt;/co
      
    
    </summary>
    
    
      <category term="web前端知识储备" scheme="http://yoursite.com/tags/web%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/"/>
    
  </entry>
  
  <entry>
    <title>单页面应用（SPA）的原理</title>
    <link href="http://yoursite.com/2019/08/07/web%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/"/>
    <id>http://yoursite.com/2019/08/07/web前端知识储备/</id>
    <published>2019-08-07T04:50:17.000Z</published>
    <updated>2019-08-07T06:15:40.408Z</updated>
    
    <content type="html"><![CDATA[<p>##知识点1：路由</p><p>路由：导航、访问不同（文件）数据的一种解决方案（对于B、C端就是访问路径）。</p><p>先由后端提出的概念，最初基于BS结构，之后出现了Ajax、XMLHttpRequest ，刷新问题解决了。但是随着发展，尤其是SPA的发展，随着页面stack的不断压入、层级加深，一刷新就会回退回根页面（也就是初始页面）导致用户体验很差、并且不利于搜索引擎收录关键字；所以前段也出现了路由的概念（解析URL，基于innerHTML这一属性使同一DOM中加载指定路劲、不同文件HTML代码以达到不刷新页面就能展示新数据的目的）。</p><p>前端路由的实现方案：hash（2014年之前）与history（基于HTML5）</p><ul><li><p>1.Hash路由（#锚点后面的值）</p><p>  例如：<a href="https://xxx.com/xx/xx#xxxx" target="_blank" rel="noopener">https://xxx.com/xx/xx#xxxx</a> ，浏览器自带监听方法</p><p>  <code>window.addEventListener(&#39;hashchange&#39;, (e) =&gt; { //do some refresh }</code></p></li><li><p>2.history路由</p><p><code>history.pushState(state,title,url)，  history.replaceState(state,title,url)，</code></p><p>  然后可以通过ajax实现单页面的数据刷新效果。</p></li></ul><p>React、Vue、angular框架的路由也是基于这两种方式。而页面的刷新方式还采用了virtual DOM，计算与原DOM的匹配度，即修改了哪里，找出变化处，刷新局部UI。这个算法可能是树遍历或者map遍历，给每个component添加Index、对应的数据是否有无变化的布尔值，有，重新绘制组件，无就跳过。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##知识点1：路由&lt;/p&gt;
&lt;p&gt;路由：导航、访问不同（文件）数据的一种解决方案（对于B、C端就是访问路径）。&lt;/p&gt;
&lt;p&gt;先由后端提出的概念，最初基于BS结构，之后出现了Ajax、XMLHttpRequest ，刷新问题解决了。但是随着发展，尤其是SPA的发展，随着页面
      
    
    </summary>
    
    
      <category term="web前端知识储备" scheme="http://yoursite.com/tags/web%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/"/>
    
  </entry>
  
  <entry>
    <title>hello hexo</title>
    <link href="http://yoursite.com/2019/08/06/hello/"/>
    <id>http://yoursite.com/2019/08/06/hello/</id>
    <published>2019-08-06T05:26:51.000Z</published>
    <updated>2019-08-07T02:05:34.500Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始了个人博客的搭建，在此记录留念。希望自己能一直保持初心不忘。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天开始了个人博客的搭建，在此记录留念。希望自己能一直保持初心不忘。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="萌新报道" scheme="http://yoursite.com/tags/%E8%90%8C%E6%96%B0%E6%8A%A5%E9%81%93/"/>
    
  </entry>
  
</feed>
