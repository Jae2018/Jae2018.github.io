<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android Proguard记录及通用配置]]></title>
    <url>%2F2019%2F08%2F14%2FAndroid-Proguard%E8%AE%B0%E5%BD%95%E5%8F%8A%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Android混淆知识记录目前网上这方面的文章一大堆，在此记录有效重点部分。 1、混淆在gradle中的配置代码123456789buildTypes &#123; release &#123; minifyEnabled true // 混淆 zipAlignEnabled true // Zipalign优化 shrinkResources true // 移除无用的resource文件 proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; // 加载默认混淆配置文件 signingConfig signingConfigs.relealse // 签名 &#125; &#125; 2、目前公认的无需混淆的地方 枚举 自定义控件 四大组件 实体类 被反射的元素 JNI调用的Java方法 native方法 第三方库 3、retrace的使用混淆后会在./build/outputs/mapping/release/下生成映射文件及其他说明文件。 dump.txt说明 APK 内所有类文件的内部结构。 mapping.txt提供混淆前后的内容对照表，内容主要包含类、方法和类的成员变量。 seeds.txt罗列出未进行混淆处理的类和成员。 usage.txt罗列出从 APK 中移除的代码。 在Android SDK目录下的/tools/proguard/bin中，双击proguardgui.bat可执行文件，然后导入mapping文件与粘上报错代码。就可查看对应的错误源代码。 注意事项： mapping每次build都不一样，需要留存副本； 提示unknown报错在proguard-rules.pro中放开下行代码： 12# 保留源文件名和具体代码行号-keepattributes SourceFile,LineNumberTable 4、自定义Proguard模板原理：因为Java语言是支持双字符的，所以可以将包名，类名，变量名，方法名定义成中文，或者其他国家的语言都可以的。 自己在项目根目录下new一个TXT文件，名字随便取，里面加入很多行字符在Proguard-rules.pro 中加入： 123-obfuscationdictionary ../your-proguard-new-dic.txt-packageobfuscationdictionary ../your-proguard-new-dic.txt-classobfuscationdictionary ../your-proguard-new-dic.txt 使用GitHub上的Proguard开源项目 下载下来后修改SimpleNameFactory.java与SourceFileRenamee.java文件 123456789101112131415161718192021222324252627282930313233343536public class SimpleNameFactory implements NameFactory &#123; /** * u4e00 - u9fa5 (中文) * x3130 - x318F (韩文) * u800 - u4e00 (日文) * 0F00 - 0FFF (藏文) */ private static final int CHARACTER_COUNT = /*26*/ 0x9fa5-0x4e00; private static final int CHARACTER_START = 0x4f99; /** * 随机生成一个五字符串内容 */ private String stringAt(int index)&#123; return new String(new char[]&#123; (char)(CHARACTER_START + index), (char)(CHARACTER_START + 1 + index), (char)(CHARACTER_START + 2 +index), (char)(CHARACTER_START + 3 +index), (char)(CHARACTER_START + 4 +index), &#125;); &#125; /** * 生成新的名字 */ private String newName(int index)&#123; int baseIndex = index / CHARACTER_COUNT; int offset = index % CHARACTER_COUNT; String newStr = stringAt(offset);//取到中文字符串 String newName = baseIndex == 0 ? new String(newStr) : (name(baseIndex - 1) + newStr) return newName; &#125;&#125; 混淆后的效果跟上面的一样。 通用基础混淆配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136# 设置混淆的压缩比率 0 ~ 7-optimizationpasses 5 # 混淆时不使用大小写混合，混淆后的类名为小写-dontusemixedcaseclassnames # 指定不去忽略非公共库的类-dontskipnonpubliclibraryclasses# 指定不去忽略非公共库的成员-dontskipnonpubliclibraryclassmembers# 混淆时不做预校验-dontpreverify# 混淆时不记录日志-verbose# 忽略警告-ignorewarning# 代码优化-dontshrink # 不优化输入的类文件，个人需求添加，开启无法去掉日志# -dontoptimize# 保留注解不混淆，这行按个人需求添加# -keepattributes *Annotation*,InnerClasses# 避免混淆泛型-keepattributes Signature # 保留代码行号，方便异常信息的追踪-keepattributes SourceFile,LineNumberTable # 混淆采用的算法-optimizations !code/simplification/cast,!field/*,!class/merging/* # dump.txt文件列出apk包内所有class的内部结构-dump class_files.txt# seeds.txt文件列出未混淆的类和成员-printseeds seeds.txt# usage.txt文件列出从apk中删除的代码-printusage unused.txt# mapping.txt文件列出混淆前后的映射-printmapping mapping.txt# 不需要混淆的类-keep public class * extends android.app.Fragment-keep public class * extends android.app.Activity-keep public class * extends android.app.Application-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.preference.Preference-keep public class * extends android.content.ContentProvider-keep public class * extends android.support.v4.**-keep public class * extends android.support.annotation.**-keep public class * extends android.support.v7.**-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference-keep public class * extends android.view.View-keep public class com.android.vending.licensing.ILicensingService# 如果是androidx包，更换包名，可省略v4、v7、design等support的配置语句-keep class android.support.** &#123;*;&#125;# v4-dontwarn android.support.v4.**-keep class android.support.v4.app.** &#123; *; &#125;-keep interface android.support.v4.app.** &#123; *; &#125;-keep class android.support.v4.** &#123; *; &#125;# v7-dontwarn android.support.v7.**-keep class android.support.v7.internal.** &#123; *; &#125;-keep interface android.support.v7.internal.** &#123; *; &#125;-keep class android.support.v7.** &#123; *; &#125;# design-dontwarn android.support.design.**-keep class android.support.design.** &#123; *; &#125;-keep interface android.support.design.** &#123; *; &#125;-keep public class android.support.design.R$* &#123; *; &#125;# 自定义控件-keep public class * extends android.view.View&#123; *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125;#关闭日志-assumenosideeffects class android.util.Log &#123; public static *** d(...); public static *** v(...); public static *** i(...); public static *** e(...); public static *** w(...);&#125;#避免资源混淆-keep class **.R$* &#123;*;&#125;#避免layout中onclick方法（android:onclick=&quot;onClick&quot;）混淆-keepclassmembers class * extends android.app.Activity&#123; public void *(android.view.View);&#125;#避免回调函数 onXXEvent 混淆-keepclassmembers class * &#123; void *(*Event);&#125;#避免混淆native方法-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;#避免Parcelable混淆，也可在实体类中加入@Keep注释-keep class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator *;&#125;#避免Serializable接口的子类中指定的某些成员变量和方法混淆-keepclassmembers class * implements java.io.Serializable &#123; static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; !static !transient &lt;fields&gt;; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();&#125;#WebView混淆配置-keepclassmembers class fqcn.of.javascript.interface.for.webview &#123; public *;&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String);&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.webView, jav.lang.String);&#125;#第三方库混淆规则都有proguard文件，直接copy加入，没有就自己写-keep***&#123;*&#125; 参考资料1、Android安全防护之旅—带你把Apk混淆成中文语言代码2、ProGuard 最全混淆规则说明3、一篇文章带你领略Android混淆的魅力4、Android常用混淆配置]]></content>
      <tags>
        <tag>Android基础知识笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android UI —— Activity、Window、View]]></title>
    <url>%2F2019%2F08%2F09%2FAndroid%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[网上有很多关于此内容的文章，在此记录我认为重点的部分。 首先是概念性的东西：1、window、phoneWindow、decorView window，抽象类，本质是surface。phoneWindow，window的实际实现类。decorView，实际显示中view层最顶层节点，由phoneWindow实例化。window按层级优先级排序分为三种，数字越大，优先级越高，越在最上面。 window 层级 应用window 1 ~ 99 子window 1000 ~ 1999 系统window 2000 ~ 2999 WindowManger、WindowMangerImpl、WindowMangerGlobal、WindowMangerServiceWindowManger是扩展了ViewManger的接口；WindowMangerImpl是其简单的实现类、所有工作交给了WindowMangerGlobal实体去处理，管理着所有window下面所有的view、viewgroup、ViewRootImpl 。WindowMangerService是Android系统架构中的管理所有窗口的服务类，它会为每个应用分配一个session，WindowMangerGlobal会通过IWindowSession这一Binder对象调用session，session再调用WMS来处理window 2、Activity、ActivityMangerService、ActivityThread调用关系 3、View、ViewRoot、ViewRootImplView的事件处理都在ViewRoot类中，然后通过Window回调给Activity。 4、Activity、Window、View调用关系 相关引用资料1、一篇文章看明白 Activity 与 Window 与 View 之间的关系2、Android 带你彻底理解 Window 和 WindowManager3、Android绘制流程4、源码分析篇 - Android绘制流程（一）窗口启动流程分析]]></content>
      <tags>
        <tag>Android原理知识汇总</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器渲染的原理]]></title>
    <url>%2F2019%2F08%2F07%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E7%9A%84%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[(本文摘抄自耗子叔的博客，更多详情请查看原文)Google Developer的说明，也可以直接查看cn的。 以下是google上查找的浏览器重排的绘制视频：]]></content>
      <tags>
        <tag>web前端知识储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web双向绑定的原理]]></title>
    <url>%2F2019%2F08%2F07%2Fweb%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[JS方法Object.defineProperty()，此方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。1、语法Object.defineProperty(obj, prop, descriptor)2、参数Obj：要在其上定义属性的对象。Prop：要定义或修改的属性的名称。Descriptor：将被定义或修改的属性描述符 数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。存取描述符是由getter-setter函数对描述的属性。描述符必须是这两种形式之一；不能同时是两者。数据描述符和存取描述符均具有以下可选键值： configurable当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。 enumerable当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。 数据描述符同时具有以下可选键值： value该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认undefined。 writable当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。存取描述符同时具有以下可选键值： get一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。默认为 undefined。 set一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。默认为 undefined。 描述符可同时具有的键值 configurable enumerable value writable get set 数据描述符 Yes Yes Yes Yes No 存取描述符 Yes Yes No No Yes 如果一个描述符不具有value,writable,get 和 set 任意一个关键字，那么它将被认为是一个数据描述符。如果一个描述符同时有(value或writable)和(get或set)关键字，将会产生一个异常。]]></content>
      <tags>
        <tag>web前端知识储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单页面应用（SPA）的原理]]></title>
    <url>%2F2019%2F08%2F07%2Fweb%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87%2F</url>
    <content type="text"><![CDATA[##知识点1：路由 路由：导航、访问不同（文件）数据的一种解决方案（对于B、C端就是访问路径）。 先由后端提出的概念，最初基于BS结构，之后出现了Ajax、XMLHttpRequest ，刷新问题解决了。但是随着发展，尤其是SPA的发展，随着页面stack的不断压入、层级加深，一刷新就会回退回根页面（也就是初始页面）导致用户体验很差、并且不利于搜索引擎收录关键字；所以前段也出现了路由的概念（解析URL，基于innerHTML这一属性使同一DOM中加载指定路劲、不同文件HTML代码以达到不刷新页面就能展示新数据的目的）。 前端路由的实现方案：hash（2014年之前）与history（基于HTML5） 1.Hash路由（#锚点后面的值） 例如：https://xxx.com/xx/xx#xxxx ，浏览器自带监听方法 window.addEventListener(&#39;hashchange&#39;, (e) =&gt; { //do some refresh } 2.history路由 history.pushState(state,title,url)， history.replaceState(state,title,url)， 然后可以通过ajax实现单页面的数据刷新效果。 React、Vue、angular框架的路由也是基于这两种方式。而页面的刷新方式还采用了virtual DOM，计算与原DOM的匹配度，即修改了哪里，找出变化处，刷新局部UI。这个算法可能是树遍历或者map遍历，给每个component添加Index、对应的数据是否有无变化的布尔值，有，重新绘制组件，无就跳过。]]></content>
      <tags>
        <tag>web前端知识储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello hexo]]></title>
    <url>%2F2019%2F08%2F06%2Fhello%2F</url>
    <content type="text"><![CDATA[今天开始了个人博客的搭建，在此记录留念。希望自己能一直保持初心不忘。]]></content>
      <tags>
        <tag>萌新报道</tag>
      </tags>
  </entry>
</search>
